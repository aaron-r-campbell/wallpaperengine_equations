<!DOCTYPE html>
<html>

<head>
    <!-- Include styles -->
    <!-- <link rel="stylesheet" type="text/css" href="styles/style.scss"> -->
    <style>
        :root {
            --background_color: #FFFFFFFF;
            --canvas_color: #FFFFFFFF;
            --shadow_color: #00000011;
            --font_color: #000000FF;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            background-color: var(--background_color);
        }

        #content_wrapper {
            position: absolute;
            left: 50%;
            top: 50%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }

        #main_canvas {
            background-color: var(--canvas_color);
        }

        #title {
            margin-right: 0.618rem;
            font-size: 1.1rem;
            color: var(--font_color);
        }

        /* Fixing MathJax */
        mjx-container {
            margin-right: 0;
            text-align: right;
        }
    </style>
    <!-- Include MathJax for LaTeX rendering -->
    <script src="scripts/mathjax.js"></script>
    <!-- Include canvas_scene.js for overall theme setup -->
    <script type="text/javascript" src="scripts/canvas_scene.js"></script>
    <!-- Include math.js -->
    <script type="text/javascript" src="scripts/math.js"></script>
</head>

<body>
    <div id="content_wrapper">
        <canvas id="main_canvas"></canvas>
        <h1 id="title" class="title"></h1>
    </div>
</body>

<footer>
    <!-- Quickly load the backdrop -->
    <script type="text/javascript">
        // Define canvas and context
        let c = document.getElementById('main_canvas');
        let ctx = c.getContext('2d');
        let t = document.getElementById('title');

        // Define and set colors
        let currentColors = setColors();

        // Set canvas orientation
        const canvas_orientation = 'auto';

        // Draw blank canvas
        clearContent(c, ctx, t);
        resizeCanvas(c, canvas_orientation);
        ctx.save();
    </script>
    <!-- Main script execution -->
    <script type="text/javascript">

        // Other
        let update_interval = 10;
        let equation_queue = [];
        let history = [];
        let history_size = equations.length;
        let currentFunction;
        let monitor_count = 1;

        window.onresize = () => {
            resizeCanvas(c, canvas_orientation);
            drawFunction();
        }

        let getNewFunction = () => {
            storeToHistory();
            if (equation_queue.length < monitor_count) equation_queue = equations.sort(() => Math.random() - 0.5).concat(equation_queue);
            while (equation_queue.length > history_size * 2) equation_queue.shift();
        }

        let storeToHistory = () => {
            history.push(equation_queue.pop());
            while (history.length > history_size) history.shift();
        }

        let recoverHistory = () => {
            if (history.length < monitor_count) history = equations.sort(() => Math.random() - 0.5).concat(history);
            equation_queue.push(history.pop());
        }

        let drawFunction = () => {
            clearContent(c, ctx, t);
            resizeCanvas(c, canvas_orientation);
            // Draw the new function
            equation_queue[equation_queue.length - 1](c, ctx, currentColors.stroke_color);
        }

        let drawNewFunction = () => {
            getNewFunction();
            drawFunction();
        }

        window.onkeydown = (evt) => {
            switch (evt.keyCode) {
                case 112: // f1 (back)
                    evt.preventDefault();
                    recoverHistory();
                    drawFunction();
                    break;
                case 113: // f2 (forward)
                    evt.preventDefault();
                    getNewFunction();
                    drawFunction();
                    break;
                default:
                    return;
            }
        };

        let main = () => {
            drawNewFunction();
            history = [];
            setInterval(drawNewFunction(), update_interval * 60 * 1000);
        }

        main();
    </script>
</footer>

</html>